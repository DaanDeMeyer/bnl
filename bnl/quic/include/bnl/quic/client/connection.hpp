#pragma once

#include <bnl/base/buffer.hpp>
#include <bnl/quic/client/handshake.hpp>
#include <bnl/quic/client/ngtcp2/connection.hpp>
#include <bnl/quic/client/stream.hpp>
#include <bnl/quic/clock.hpp>
#include <bnl/quic/crypto.hpp>
#include <bnl/quic/event.hpp>
#include <bnl/quic/export.hpp>
#include <bnl/quic/params.hpp>
#include <bnl/quic/path.hpp>
#include <bnl/quic/result.hpp>

#include <map>
#include <random>

namespace bnl {
namespace quic {
namespace client {

class connection;

class BNL_QUIC_EXPORT generator {
public:
  explicit generator(connection &connection);

  bool next();

  result<event> get();

private:
  connection &connection_;
};

class BNL_QUIC_EXPORT connection {
public:
  connection(const ip::host &host,
             path path,
             const params &params,
             clock clock) noexcept;

  connection(connection &&) = default;
  connection &operator=(connection &&) = default;

  ~connection() = default;

  result<base::buffer> send();

  result<generator> recv(base::buffer_view data);

  duration timeout() const noexcept;
  duration expiry() const noexcept;

  result<void> expire();

  result<void> add(quic::event event);

private:
  result<void> add(quic::data data);

private:
  friend class generator;
  friend class ngtcp2::connection;

  result<void> client_initial();

  result<void> recv_crypto_data(crypto::level level, base::buffer_view data);

  void handshake_completed();

  void recv_stream_data(uint64_t id, bool fin, base::buffer_view data);

  result<void> acked_crypto_offset(crypto::level level, size_t size);

  result<void> acked_stream_data_offset(uint64_t id, size_t size);

  void stream_opened(uint64_t id);
  void stream_closed(uint64_t id, uint64_t error);
  void stream_reset(uint64_t id, uint64_t final_size, uint64_t error);

  result<void> recv_stateless_reset(base::buffer_view bytes,
                                    base::buffer_view token);

  result<void> recv_retry(base::buffer_view dcid);

  void extend_max_local_streams_bidi(uint64_t max_streams);
  void extend_max_local_streams_uni(uint64_t max_streams);
  void extend_max_remote_streams_bidi(uint64_t max_streams);
  void extend_max_remote_streams_uni(uint64_t max_streams);

  void random(base::buffer_view_mut dest);

  void new_connection_id(base::buffer_view_mut dest);
  void new_stateless_reset_token(base::buffer_view_mut dest);

  void remove_connection_id(base::buffer_view cid);

  result<void> update_key();

  result<void> path_validation(base::buffer_view local,
                               base::buffer_view peer,
                               bool succeeded);

  result<void> select_preferred_address(base::buffer_view_mut dest,
                                        ip::endpoint ipv4,
                                        ip::endpoint ipv6,
                                        base::buffer_view token);

  void extend_max_stream_data(uint64_t id, uint64_t max_data);

  result<quic::crypto> crypto() const noexcept;

private:
  std::mt19937 prng_;

  std::map<uint64_t, stream> streams_;

  // Stores events generated by ngtcp2 callbacks until they can be returned in
  // `recv`.
  std::list<result<quic::event>> event_buffer_;

  uint64_t max_local_bidi_streams_ = 0;
  uint64_t max_local_uni_streams_ = 0;
  uint64_t max_remote_bidi_streams_ = 0;
  uint64_t max_remote_uni_streams_ = 0;

  ngtcp2::connection ngtcp2_;
  handshake handshake_;
  quic::path path_;
};

}
}
}
