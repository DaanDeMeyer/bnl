#pragma once

#include <bnl/base/buffer.hpp>
#include <bnl/base/result.hpp>
#include <bnl/quic/client/handshake.hpp>
#include <bnl/quic/client/ngtcp2/connection.hpp>
#include <bnl/quic/client/stream.hpp>
#include <bnl/quic/clock.hpp>
#include <bnl/quic/crypto.hpp>
#include <bnl/quic/event.hpp>
#include <bnl/quic/export.hpp>
#include <bnl/quic/params.hpp>
#include <bnl/quic/path.hpp>

#include <random>
#include <system_error>
#include <unordered_map>

namespace bnl {

namespace log {
class api;
}

namespace quic {
namespace client {

class BNL_QUIC_EXPORT connection {
public:
  connection(path path,
             const params &params,
             clock clock,
             const log::api *logger) noexcept;

  connection(connection &&other) = default;
  connection &operator=(connection &&other) = default;

  ~connection() = default;

  base::result<base::buffer> send();

  std::error_code recv(base::buffer_view data, event::handler handler);

  duration timeout() const noexcept;
  duration expiry() const noexcept;

  std::error_code expire();

  std::error_code add(quic::event event);

  base::result<uint64_t> open_bidi_stream();

private:
  friend class ngtcp2::connection;

  std::error_code client_initial();

  std::error_code recv_crypto_data(crypto::level level, base::buffer_view data);

  void handshake_completed();

  void recv_stream_data(uint64_t id, bool fin, base::buffer_view data);

  std::error_code acked_crypto_offset(crypto::level level, size_t size);

  std::error_code acked_stream_data_offset(uint64_t id, size_t size);

  void stream_opened(uint64_t id);
  void stream_closed(uint64_t id, uint64_t error);
  void stream_reset(uint64_t id, uint64_t final_size, uint64_t error);

  std::error_code recv_stateless_reset(base::buffer_view bytes,
                                       base::buffer_view token);

  std::error_code recv_retry(base::buffer_view dcid);

  void extend_max_local_streams_bidi(uint64_t max_streams);
  void extend_max_local_streams_uni(uint64_t max_streams);
  void extend_max_remote_streams_bidi(uint64_t max_streams);
  void extend_max_remote_streams_uni(uint64_t max_streams);

  void random(base::buffer_view_mut dest);

  void new_connection_id(base::buffer_view_mut dest);
  void new_stateless_reset_token(base::buffer_view_mut dest);

  void remove_connection_id(base::buffer_view cid);

  std::error_code update_key();

  std::error_code path_validation(base::buffer_view local,
                                  base::buffer_view remote,
                                  bool succeeded);

  std::error_code select_preferred_address(base::buffer_view_mut dest,
                                           ip::endpoint ipv4,
                                           ip::endpoint ipv6,
                                           base::buffer_view token);

  void extend_max_stream_data(uint64_t id, uint64_t max_data);

  const log::api *logger() const noexcept;
  base::result<quic::crypto> crypto() const noexcept;

private:
  std::mt19937 prng_;

  std::unordered_map<uint64_t, stream> streams_;

  // Stores events generated by ngtcp2 callbacks until they can be returned in
  // `recv`.
  std::list<quic::event> event_buffer_;

  uint64_t max_local_bidi_streams_ = 0;
  uint64_t max_local_uni_streams_ = 0;
  uint64_t max_remote_bidi_streams_ = 0;
  uint64_t max_remote_uni_streams_ = 0;

  ngtcp2::connection ngtcp2_;
  handshake handshake_;
  quic::path path_;

  const log::api *logger_;
};

}
}
}
