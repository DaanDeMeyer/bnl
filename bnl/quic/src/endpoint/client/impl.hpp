#include <bnl/base/buffers.hpp>
#include <bnl/quic/event.hpp>
#include <bnl/quic/export.hpp>
#include <bnl/quic/params.hpp>

#include <endpoint/client/handshake.hpp>
#include <endpoint/client/ngtcp2/connection.hpp>
#include <endpoint/shared/crypto.hpp>

#include <unordered_map>

namespace bnl {
namespace quic {
namespace endpoint {
namespace client {

class BNL_QUIC_EXPORT impl
{
public:
  impl(path path,
       const params& params,
       clock clock,
       const log::api* logger) noexcept;

  impl(impl&& other) = default;
  impl& operator=(impl&& other) = default;

  std::error_code client_initial();

  std::error_code recv_crypto_data(crypto::level level, base::buffer_view data);

  void handshake_completed();

  void recv_stream_data(uint64_t id, bool fin, base::buffer_view data);

  std::error_code acked_crypto_offset(crypto::level level, size_t size);

  std::error_code acked_stream_data_offset(uint64_t id, size_t size);

  void stream_opened(uint64_t id);
  void stream_closed(uint64_t id, uint64_t error);
  void stream_reset(uint64_t id, size_t final_size, uint64_t error);

  std::error_code recv_stateless_reset(base::buffer_view bytes,
                                       base::buffer_view token);

  std::error_code recv_retry(base::buffer_view dcid);

  void extend_max_local_streams_bidi(uint64_t max_streams);
  void extend_max_local_streams_uni(uint64_t max_streams);
  void extend_max_remote_streams_bidi(uint64_t max_streams);
  void extend_max_remote_streams_uni(uint64_t max_streams);

  void random(base::buffer_view_mut dest);

  void new_connection_id(base::buffer_view_mut dest);
  void new_stateless_reset_token(base::buffer_view_mut dest);

  void remove_connection_id(base::buffer_view cid);

  std::error_code update_key();

  std::error_code path_validation(base::buffer_view local,
                                  base::buffer_view remote,
                                  bool succeeded);

  std::error_code select_preferred_address(base::buffer_view_mut dest,
                                           ip::endpoint ipv4,
                                           ip::endpoint ipv6,
                                           base::buffer_view token);

  void extend_max_stream_data(uint64_t id, uint64_t max_data);

  base::result<base::buffer> send();

  std::error_code recv(base::buffer_view data, event::handler handler);

  void add(quic::event event);

  duration timeout() const noexcept;
  duration expiry() const noexcept;

  std::error_code expire();

  const log::api* logger() const noexcept;
  base::result<quic::crypto> crypto() const noexcept;

private:
  std::mt19937 prng_;

  // These keep sent data alive until ngtcp2 tells us its been acked.
  std::unordered_map<uint64_t, base::buffers> ngtcp2_streams_keepalive_;

  // Stores events generated by ngtcp2 callbacks until they can be returned in
  // `recv`.
  std::deque<quic::event> event_buffer_;

  uint64_t max_local_bidi_streams_ = 0;
  uint64_t max_local_uni_streams_ = 0;
  uint64_t max_remote_bidi_streams_ = 0;
  uint64_t max_remote_uni_streams_ = 0;

  ngtcp2::connection ngtcp2_;
  handshake handshake_;
  quic::path path_;

  const log::api* logger_;
};

} // namespace client
} // namespace endpoint
} // namespace quic
} // namespace bnl
